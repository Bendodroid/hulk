#!/usr/bin/env python

import argparse
import os
import json
import pathlib
import sys
import typing

import cv2
import numpy as np
import termcolor


def read_replay_json(replay_json: pathlib.Path) -> typing.Tuple[typing.Optional[dict], typing.List[str]]:
    errors = []
    # read JSON contents into string, trim zero bytes from begin and end of contents
    try:
        with replay_json.open() as f:
            replay_json_contents = f.read()
    except FileNotFoundError as error:
        errors.append(repr(error))
        return None, errors
    new_replay_json_contents = replay_json_contents.strip('\x00')
    if new_replay_json_contents != replay_json_contents:
        errors.append('File contains zero bytes at begin and/or end')
        replay_json_contents = new_replay_json_contents
    # early return for empty JSON
    if len(replay_json_contents) == 0:
        errors.append('File is empty')
        return None, errors
    # early return for JSON containing only the finalizer
    if replay_json_contents.strip() == ']}':
        errors.append('File only contains finalizer \']}\'')
        return None, errors
    # first attempt: read as normal JSON
    replay_json_parsed = None
    try:
        replay_json_parsed = json.loads(replay_json_contents)
    except json.decoder.JSONDecodeError as error:
        errors.append(repr(error))
    # second attempt: with appended finalizer
    if replay_json_parsed is None:
        try:
            replay_json_parsed = json.loads(replay_json_contents + ']}')
        except json.decoder.JSONDecodeError as error:
            errors.append(repr(error))
    # sanitize some basic things of the replay.json
    if 'frames' not in replay_json_parsed:
        errors.append('Missing \'frames\' key')
        return None, errors
    if len(replay_json_parsed['frames']) > 0 and 'imageSize444' in replay_json_parsed['frames'][0]:
        errors.append('First frame contains \'imageSize444\' key, probably already converted')
        return None, errors
    return replay_json_parsed, errors


def convert_422_to_png(image_size_444: typing.Tuple[int, int], filename_422: str, filename_png: str, rgb: bool):
    # read 422 image
    bytes_422 = np.fromfile(filename_422, dtype='uint8')

    # split y, cb and cr channels (https://gist.github.com/baali/3525330)
    y = bytes_422[0::2]
    cb = bytes_422[1::4]
    cr = bytes_422[3::4]

    # shuffle y, cb and cr channels to get 444 pixels (opencv requires BGR)
    pixels = np.zeros(
        (image_size_444[0] * image_size_444[1] * 3), dtype='uint8')
    pixels[::6] = cr
    pixels[1::6] = cb
    pixels[2::3] = y
    pixels[3::6] = cr
    pixels[4::6] = cb

    image = pixels.reshape((image_size_444[1], image_size_444[0], 3))

    if rgb:
        image = cv2.cvtColor(image[..., ::-1], cv2.COLOR_YCrCb2BGR)[..., ::-1]

    # write 444 PNG
    cv2.imwrite(filename_png, image)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Converts 422 replay data to PNGs. Takes one or many directories which contain 422 files with an optional replay.json.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('directories', metavar='PATH', type=str, nargs='+',
                        help='directory containing 422 files and an optional replay.json')
    parser.add_argument('--rgb', action='store_true',
                        help='also convert images from YCbCr to RGB')
    parser.add_argument('--image-size-422', default='[320,480]',
                        help='size of images not contained in any replay.json')
    arguments = parser.parse_args()
    image_size_422 = json.loads(arguments.image_size_422)

    print(f'Reading replay.json of {", ".join(arguments.directories)}...')
    replay_jsons = {
        pathlib.Path(directory): read_replay_json(pathlib.Path(directory) / 'replay.json')
        for directory in arguments.directories
    }
    print()
    at_least_one_error = False
    for directory, (replay_json, errors) in replay_jsons.items():
        color = 'red'
        if replay_json is None:
            termcolor.cprint(f'Failed to read {directory / "replay.json"}, because:', 'red')
        elif replay_json is not None and len(errors) > 0:
            termcolor.cprint(f'Read {directory / "replay.json"} with the following successfully recovered errors:', 'yellow')
            color = 'yellow'
        for error in errors:
            termcolor.cprint(f'- {error}', color)
        if len(errors) > 0:
            at_least_one_error = True
            print()
    if at_least_one_error:
        answer = input('Continue with these errors? [yN] ').lower().strip()
        if len(answer) == 0 or answer[0] == 'n':
            print('Aborting.')
            sys.exit(1)

    modifications_for_replay_json = {}
    successfully_processed_422_files = []
    failed_422_files = []
    for directory, (replay_json, errors) in replay_jsons.items():
        at_least_one_error = False
        if replay_json is None:
            print(
                f'Converting all *.422 files in directory (ignoring replay.json): {directory}...')
            count = 0
            for root, directories, files in os.walk(directory):
                for file in files:
                    file = pathlib.Path(root) / file
                    if file.suffix == '.422':
                        try:
                            convert_422_to_png((image_size_422[0] * 2, image_size_422[1]), str(
                                file), str(file.with_suffix('.png')), arguments.rgb)
                            successfully_processed_422_files.append(file)
                            count += 1
                        except ValueError as error:
                            failed_422_files.append(file)
                            termcolor.cprint(
                                f'During conversion of {file} the following error occurred: {repr(error)}', 'red')
                            at_least_one_error = True
                        if count % 100 == 0 and count > 0:
                            print(f'... {count} done')
        else:
            print(
                f'Converting {len(replay_json["frames"])} *.422 files from {directory / "replay.json"}...')
            modifications_for_replay_json[directory] = {
                'frames_with_errors': [],
                'file_names_444': [],
                'image_sizes_444': [],
            }
            for frame_index, frame in enumerate(replay_json['frames']):
                is_top_image = 'topImage' in frame
                file_422 = directory / \
                    (frame['topImage'] if is_top_image else frame['bottomImage'])
                file_444 = file_422.with_suffix('.png')
                size_422 = frame['imageSize422']
                try:
                    convert_422_to_png((size_422[0] * 2, size_422[1]), str(
                        file_422), str(file_444), arguments.rgb)
                    successfully_processed_422_files.append(file_422)
                    modifications_for_replay_json[directory]['frames_with_errors'].append(
                        False)
                except ValueError as error:
                    termcolor.cprint(
                        f'During conversion of {file} the following error occurred: {repr(error)}', 'red')
                    termcolor.cprint(
                        'This file will be excluded from output replay.json', 'red')
                    failed_422_files.append(file_422)
                    at_least_one_error = True
                    modifications_for_replay_json[directory]['frames_with_errors'].append(
                        True)
                modifications_for_replay_json[directory]['file_names_444'].append(
                    file_444.name)
                modifications_for_replay_json[directory]['image_sizes_444'].append(
                    [size_422[0] * 2, size_422[1]])
                if frame_index % 100 == 0 and frame_index > 0:
                    print(f'... {frame_index} of {len(replay_json["frames"])} done')
        if at_least_one_error:
            answer = input(
                'Continue and ignore above errors? [yN] ').lower().strip()
            if len(answer) == 0 or answer[0] == 'n':
                print('Aborting.')
                sys.exit(1)

    print('Writing replay.json files...')
    replay_json_backups = []
    for directory in replay_jsons.keys():
        if replay_jsons[directory][0] is None:
            continue
        # remove frames with errors
        index_offset = 0
        for frame_index, has_error in enumerate(modifications_for_replay_json[directory]['frames_with_errors']):
            if not has_error:
                continue
            del replay_jsons[directory][0]['frames'][frame_index - index_offset]
            del modifications_for_replay_json[directory]['file_names_444'][frame_index - index_offset]
            del modifications_for_replay_json[directory]['image_sizes_444'][frame_index - index_offset]
            index_offset += 1
        # change filenames and image sizes
        for frame_index, frame in enumerate(replay_jsons[directory][0]['frames']):
            if 'topImage' in frame:
                replay_jsons[directory][0]['frames'][frame_index]['topImage'] = modifications_for_replay_json[directory]['file_names_444'][frame_index]
            else:
                replay_jsons[directory][0]['frames'][frame_index]['bottomImage'] = modifications_for_replay_json[directory]['file_names_444'][frame_index]
            del replay_jsons[directory][0]['frames'][frame_index]['imageSize422']
            replay_jsons[directory][0]['frames'][frame_index]['imageSize444'] = modifications_for_replay_json[directory]['image_sizes_444'][frame_index]
        # actually writing JSON
        replay_json_backups.append(
            (directory / 'replay.json').rename(directory / 'replay.json.bak'))
        with (directory / 'replay.json').open(mode='w') as f:
            json.dump(replay_jsons[directory][0], f)
        print(f'{directory / "replay.json"} written.')

    answer = input(
        'Remove unneeded replay.json.bak backup files? [Yn] ').lower().strip()
    if len(answer) == 0 or answer[0] == 'y':
        print(
            f'Removing {len(replay_json_backups)} unneeded replay.json.bak backup files...')
        for replay_json_backup in replay_json_backups:
            replay_json_backup.unlink()
        print('Done.')

    answer = input('Remove unneeded *.422 files? [Yn] ').lower().strip()
    if len(answer) == 0 or answer[0] == 'y':
        print(
            f'Removing {len(successfully_processed_422_files)} unneeded *.422 files ({len(failed_422_files)} errored files will remain)...')
        for file_to_be_removed in successfully_processed_422_files:
            file_to_be_removed.unlink()
        if len(failed_422_files) > 0:
            print(
                f'The following {len(failed_422_files)} files have been left untouched:')
        for remaining_file in failed_422_files:
            print(remaining_file)
        print('Done.')
